import { firestore, credential, initializeApp, ServiceAccount } from 'firebase-admin'
import { ExtendedServiceAccount, FilterOptions, ExtendedDocument } from './interfaces';
import { checkServiceAccount, docMapper } from './helper'

export class FirestoreClient {
  
  private databases: any = { default: {} }

  constructor(connectionCredentials: ExtendedServiceAccount[] | ServiceAccount, defaultDbIdentifier?: string) {
    if (!connectionCredentials) throw new Error(`Service Accounts missing`);
    if (connectionCredentials instanceof Array) {
      if (!defaultDbIdentifier) throw new Error('Identifier for default database is required')
      for (const credentials of connectionCredentials) {
        checkServiceAccount(credentials.serviceAccount, credentials.identifier)
        this.databases[credentials.identifier === defaultDbIdentifier ? 'default' : credentials.identifier] = initializeApp({
          credential: credential.cert(credentials.serviceAccount)
        }, credentials.identifier).firestore()
      }
    } else {
      checkServiceAccount(connectionCredentials)
      this.databases.default = initializeApp({
        credential: credential.cert(connectionCredentials)
      }).firestore()
    }
  }
  
  public getDatabase(dbIdentifier?: string): firestore.Firestore {
    return this.databases[dbIdentifier || 'default']
  }

  public getDbCollection(collection: string, dbIdentifier?: string): firestore.CollectionReference {
    return this.getDatabase(dbIdentifier).collection(collection)
  }

  public async getDoc(collection: string, id: string, dbIdentifier?: string): Promise<firestore.DocumentData> {
    const docSnapshot = await this.getDbCollection(collection, dbIdentifier).doc(id).get()
    if (!docSnapshot.exists) throw new Error('Document does not exist')
    return docSnapshot.data() || {}
  }

  public async getDocs(collection: string, ids: string[], dbIdentifier?: string): Promise<ExtendedDocument[]> {
    const docRefs = ids.map(id => this.getDbCollection(collection, dbIdentifier).doc(id))
    const dataSets = await this.getDatabase(dbIdentifier).getAll(...docRefs)
    return dataSets.map(docMapper)
  }

  public async getAllDocs(collection: string, dbIdentifier?: string): Promise<firestore.QuerySnapshot> {
    return this.getDbCollection(collection, dbIdentifier).get()
  }

  public async getDocWithFilter(collection: string, filterParams: FilterOptions, dbIdentifier?: string): Promise<ExtendedDocument> {
    const query = await this.getDbCollection(collection, dbIdentifier).where(filterParams.fieldPath, filterParams.opStr, filterParams.value).limit(1).get()
    return query.docs.map(docMapper)[0]
  }

  public async getDocsWithFilter(collection: string, filterParams: FilterOptions, dbIdentifier?: string): Promise<ExtendedDocument[]> {
    const query = await this.getDbCollection(collection, dbIdentifier).where(filterParams.fieldPath, filterParams.opStr, filterParams.value).get()
    return query.docs.map(docMapper)
  }

  public async createDoc(collection: string, payload: any, id?: string, dbIdentifier?: string): Promise<string> {
    if (id) {
      await this.getDbCollection(collection, dbIdentifier).doc(id).set({ ...payload })
      return id
    } else {
      const newDocument = await this.getDbCollection(collection, dbIdentifier).add({ ...payload })
      return newDocument.id
    }
  }

  public async updateDoc(collection: string, id: string, payload: any, dbIdentifier?: string): Promise<firestore.WriteResult> {
    return this.getDbCollection(collection, dbIdentifier).doc(id).update(payload)
  }

  public async upsertDoc(collection: string, id: string, payload: any, dbIdentifier?: string): Promise<any> {
    await this.getDbCollection(collection, dbIdentifier).doc(id).set({ ...payload }, { merge: true })
    return payload
  }

  public async upsertDocsWithFilter(collection: string, payload: any, filterParams: FilterOptions, dbIdentifier?: string): Promise<any> {
    const docsToUpsert = await this.getDocsWithFilter(collection, filterParams, dbIdentifier)
    if (docsToUpsert.length) {
      for (const doc of docsToUpsert) {
        await this.upsertDoc(collection, doc.id, payload, dbIdentifier)
      }
    } else {
      throw new Error('No documents found')
    }
    return payload
  }

  public async getDocsWithMultipleFilters(collection: string, filterParams: FilterOptions [], dbIdentifier?: string): Promise<any> {
    let collectionRef: firestore.CollectionReference = this.getDbCollection(collection, dbIdentifier)
    let query: firestore.Query = collectionRef
    for (let i = 0; i < filterParams.length; i++) {
      const { fieldPath, opStr, value } = filterParams[i]
      query = query.where(fieldPath, opStr, value)
    }
    const querySnapShot: firestore.QuerySnapshot = await query.get()
    return querySnapShot.docs.map(docMapper)
  }

  public async deleteDoc(collection: string, id: string, dbIdentifier?: string): Promise<void> {
    await this.getDbCollection(collection, dbIdentifier).doc(id).delete()
  }
}