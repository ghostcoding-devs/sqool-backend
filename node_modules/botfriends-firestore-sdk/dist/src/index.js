"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const firebase_admin_1 = require("firebase-admin");
const helper_1 = require("./helper");
class FirestoreClient {
    constructor(connectionCredentials, defaultDbIdentifier) {
        this.databases = { default: {} };
        if (!connectionCredentials)
            throw new Error(`Service Accounts missing`);
        if (connectionCredentials instanceof Array) {
            if (!defaultDbIdentifier)
                throw new Error('Identifier for default database is required');
            for (const credentials of connectionCredentials) {
                helper_1.checkServiceAccount(credentials.serviceAccount, credentials.identifier);
                this.databases[credentials.identifier === defaultDbIdentifier ? 'default' : credentials.identifier] = firebase_admin_1.initializeApp({
                    credential: firebase_admin_1.credential.cert(credentials.serviceAccount)
                }, credentials.identifier).firestore();
            }
        }
        else {
            helper_1.checkServiceAccount(connectionCredentials);
            this.databases.default = firebase_admin_1.initializeApp({
                credential: firebase_admin_1.credential.cert(connectionCredentials)
            }).firestore();
        }
    }
    getDatabase(dbIdentifier) {
        return this.databases[dbIdentifier || 'default'];
    }
    getDbCollection(collection, dbIdentifier) {
        return this.getDatabase(dbIdentifier).collection(collection);
    }
    async getDoc(collection, id, dbIdentifier) {
        const docSnapshot = await this.getDbCollection(collection, dbIdentifier).doc(id).get();
        if (!docSnapshot.exists)
            throw new Error('Document does not exist');
        return docSnapshot.data() || {};
    }
    async getDocs(collection, ids, dbIdentifier) {
        const docRefs = ids.map(id => this.getDbCollection(collection, dbIdentifier).doc(id));
        const dataSets = await this.getDatabase(dbIdentifier).getAll(...docRefs);
        return dataSets.map(helper_1.docMapper);
    }
    async getAllDocs(collection, dbIdentifier) {
        return this.getDbCollection(collection, dbIdentifier).get();
    }
    async getDocWithFilter(collection, filterParams, dbIdentifier) {
        const query = await this.getDbCollection(collection, dbIdentifier).where(filterParams.fieldPath, filterParams.opStr, filterParams.value).limit(1).get();
        return query.docs.map(helper_1.docMapper)[0];
    }
    async getDocsWithFilter(collection, filterParams, dbIdentifier) {
        const query = await this.getDbCollection(collection, dbIdentifier).where(filterParams.fieldPath, filterParams.opStr, filterParams.value).get();
        return query.docs.map(helper_1.docMapper);
    }
    async createDoc(collection, payload, id, dbIdentifier) {
        if (id) {
            await this.getDbCollection(collection, dbIdentifier).doc(id).set({ ...payload });
            return id;
        }
        else {
            const newDocument = await this.getDbCollection(collection, dbIdentifier).add({ ...payload });
            return newDocument.id;
        }
    }
    async updateDoc(collection, id, payload, dbIdentifier) {
        return this.getDbCollection(collection, dbIdentifier).doc(id).update(payload);
    }
    async upsertDoc(collection, id, payload, dbIdentifier) {
        await this.getDbCollection(collection, dbIdentifier).doc(id).set({ ...payload }, { merge: true });
        return payload;
    }
    async upsertDocsWithFilter(collection, payload, filterParams, dbIdentifier) {
        const docsToUpsert = await this.getDocsWithFilter(collection, filterParams, dbIdentifier);
        if (docsToUpsert.length) {
            for (const doc of docsToUpsert) {
                await this.upsertDoc(collection, doc.id, payload, dbIdentifier);
            }
        }
        else {
            throw new Error('No documents found');
        }
        return payload;
    }
    async getDocsWithMultipleFilters(collection, filterParams, dbIdentifier) {
        let collectionRef = this.getDbCollection(collection, dbIdentifier);
        let query = collectionRef;
        for (let i = 0; i < filterParams.length; i++) {
            const { fieldPath, opStr, value } = filterParams[i];
            query = query.where(fieldPath, opStr, value);
        }
        const querySnapShot = await query.get();
        return querySnapShot.docs.map(helper_1.docMapper);
    }
    async deleteDoc(collection, id, dbIdentifier) {
        await this.getDbCollection(collection, dbIdentifier).doc(id).delete();
    }
}
exports.FirestoreClient = FirestoreClient;
//# sourceMappingURL=index.js.map